import os
import sys

from pathlib import Path
from typing import TYPE_CHECKING
from typing import Iterator
from typing import Tuple
from typing import Union
from typing import cast

from installer.destinations import SchemeDictionaryDestination as BaseDestination
from installer.records import parse_record_file
from installer.sources import WheelFile as BaseWheelFile

from poetry import __version__
from poetry.utils._compat import WINDOWS


if TYPE_CHECKING:
    from typing import BinaryIO

    from installer.records import RecordEntry
    from installer.utils import Scheme

    from poetry.utils.env import Env


class WheelFile(BaseWheelFile):
    def get_contents(
        self,
    ) -> Iterator[Tuple[Tuple[Union[Path, str], str, str], "BinaryIO"]]:
        record_lines = self.read_dist_info("RECORD").splitlines()
        records = parse_record_file(record_lines)
        record_mapping = {record[0]: record for record in records}

        for item in self._zipfile.infolist():
            if item.is_dir():
                continue

            record = record_mapping.pop(item.filename)
            assert record is not None, "In {}, {} is not mentioned in RECORD".format(
                self._zipfile.filename,
                item.filename,
            )  # should not happen for valid wheels

            with self._zipfile.open(item) as stream:
                stream_casted = cast("BinaryIO", stream)
                yield record, stream_casted


class WheelDestination(BaseDestination):
    def write_to_fs(
        self, scheme: "Scheme", path: Union[Path, str], stream: "BinaryIO"
    ) -> "RecordEntry":
        from installer.records import Hash
        from installer.records import RecordEntry
        from installer.utils import copyfileobj_with_hashing

        target_path = os.path.join(self.scheme_dict[scheme], path)
        if os.path.exists(target_path):
            # Contrary to the base library we don't raise an error
            # here since it can break namespace packages (like Poetry's)
            pass

        parent_folder = os.path.dirname(target_path)
        if not os.path.exists(parent_folder):
            os.makedirs(parent_folder)

        with open(target_path, "wb") as f:
            hash_, size = copyfileobj_with_hashing(stream, f, self.hash_algorithm)

        return RecordEntry(path, Hash(self.hash_algorithm, hash_), size)


class WheelInstaller:
    def __init__(self, env: "Env") -> None:
        self._env = env

        if not WINDOWS:
            script_kind = "posix"
        else:
            if os.uname()[4].startsWith("arm"):
                script_kind = "win-arm64" if sys.maxsize > 2 ** 32 else "win-arm"
            else:
                script_kind = "win-amd64" if sys.maxsize > 2 ** 32 else "win-ia32"

        self._destination = WheelDestination(
            self._env.paths, interpreter=self._env.python, script_kind=script_kind
        )

    def install(self, wheel: Path) -> None:
        from installer import install

        with WheelFile.open(wheel.as_posix()) as source:
            try:
                install(
                    source=source,
                    destination=self._destination,
                    # Additional metadata that is generated by the installation tool.
                    additional_metadata={
                        "INSTALLER": f"Poetry {__version__}".encode(),
                    },
                )
            except Exception as e:
                print(e)

                raise
